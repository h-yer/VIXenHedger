---
layout: post
title: Quant Guide 101
date: 2025-03-13
tags:
 - python
images:
  path: /assets/importancesampling/simplestrat.png
  width: 500
  height: 500
---

# Quant Basics 101

## Part 1: The Basics

### 1.1 Introduction

In quantitative finance, we manage an investment portfolio with an initial capital $$N_t^{\$}$$ and decide how to allocate this across various assets daily. The goal is to determine the fraction $$w^{i}_{t}$$ of capital allocated to each asset $$S^{i}$$.

The allocation is defined as:

$$x_{t}^{i} = N_{t}^{\$} . w^{i}_{t}$$

Where:
- $$x_{t}^{i}$$: Allocation in dollars
- $$N_{t}^{\$}$$: Total capital available
- $$w^{i}_{t}$$: Fraction of capital allocated to asset $$S^{i}$$

The number of shares to hold is given by:

$$n_{t}^{i} = \frac{x_{t}^{i}}{S_{t}^{i}} = \frac{N_{t}^{\$} . w^{i}_{t}}{S_{t}^{i}}$$

We begin by setting an equal-weighted portfolio:

```python
import numpy as np

N_0 = 100_000_000  # Initial Capital
n = 3  # Number of assets
S_0 = np.array([53.0, 121.0, 93.0])

w_0 = np.ones(n) / n  # Equal-weighted allocation
x_0 = N_0 * w_0
n_0 = x_0 / S_0

print(f"Initial portfolio: {n_0}")
```

### 1.2 Leveraging the Portfolio

Leverage allows us to amplify our capital by shorting stocks. If the sum of absolute allocations exceeds 1, we are applying leverage.

Example: A leveraged portfolio with a 110% exposure:

```python
w_0_short = np.array([0.5, -0.4, 0.2])

x_0 = N_0 * w_0_short
n_0 = x_0 / S_0
leverage = np.sum(np.abs(w_0_short)) * 100

print(f"Leverage: {leverage}%")
print(f"Portfolio allocation: {n_0}")
```

### 1.3 Profit & Loss Calculation

The profit and loss (P&L) is computed as:

$$ P\&L^{i}(t, \delta) = N_{t}^{\$}.w^{i}_{t}.r_{t}^{i} $$

where $$r_{t}^{i}$$ is the return over the period.

Example:

```python
S_1 = np.array([52.0, 118.0, 94.0])  # Prices after one day
returns = S_1 / S_0 - 1

PnL_long = np.sum(N_0 * w_0 * returns)
PnL_leverage = N_0 * w_0_short @ returns

print(f"P&L (Long Only): ${PnL_long:.2f}")
print(f"P&L (Leverage): ${PnL_leverage:.2f}")
```

### 1.4 Quantitative Strategy: Momentum-Based Allocation

A simple approach is to allocate capital to assets based on historical performance. We define a rolling return metric:

$$ \mu_{t}^{f} = \sum w_{t}^{i} \left( \frac{1}{N_{T}} \sum r^{i}_{t_j, \delta t} \right)$$

#### Toy Model Example:

```python
prices = np.array([
    [53.0, 121.0, 93.0],
    [52.0, 122.0, 94.0],
    [50.0, 124.0, 96.0],
    [47.0, 127.0, 99.0],
    [43.0, 131.0, 103.0],
    [41.0, 135.0, 107.0],
    [39.0, 138.0, 110.0],
    [38.0, 140.0, 112.0],
    [34.0, 144.0, 114.0]
])

delta = 4  # Rebalancing frequency
N_T, N = prices.shape

returns = prices[1:] / prices[:-1] - 1  # Daily returns
num_rebalancing_periods, start = divmod(N_T - 1, delta)
returns_rebalanced = returns[start:].reshape(num_rebalancing_periods, delta, N)

mu_rebalancing = np.mean(returns_rebalanced, axis=1)
mu_portfolio = (mu_rebalancing @ w_0[:, None]).flatten()
print(f"Rolling Returns: {mu_portfolio}")
```

### 1.5 Risk Management: Volatility Calculation

Portfolio volatility is computed as:

$$ \sigma_t (\{w^i\}) = \sqrt{\frac{1}{N_T - 1} \sum \left( \sum w^i r^i - \mu_{\text{portfolio}} \right)^2 } $$

```python
volatility_portfolio = np.std(returns_rebalanced @ w_0, axis=1, ddof=1)
print(f"Portfolio Volatility: {volatility_portfolio}")
```

### 1.6 Performance Evaluation: Sharpe Ratio

$$ Sharpe Ratio = \frac{\mu_{\text{portfolio}}}{\sigma_t} $$

```python
sharpe_ratio = mu_portfolio / volatility_portfolio
print(f"Sharpe Ratio: {sharpe_ratio}")
```

This post introduced the fundamental concepts of quantitative investing, from portfolio allocation to risk assessment. In future posts, we will explore advanced strategies like factor investing and machine learning-based allocation.

Stay tuned for Part 2!
